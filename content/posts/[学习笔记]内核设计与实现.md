---
title: "[学习笔记]内核同设计与实现"
date: 2021-10-24T10:51:53+08:00
draft: true
---

# 进程管理
# 进程调度
# 系统调用
# 中断和中断处理

# 内核同步
临界区：访问和操作共享数据的代码段  
竞争条件：两个执行线程处于同一个临界区中同时执行

内核造成并发执行的原因： 
- 中断
- 软中断和tasklet
- 内核抢占
- 睡眠及与用户空间的同步
- 对称多处理——两个或多个处理器可以同处理代码

## 内核同步方法
### 原子整数操作
针对整数的原子操作只能对atomic_t类型的数据进行处理 
```
type struct { 
    violatile int counter; 
} atomic_t;
```
Linux支持的所有机器上的整形数据都是32位的
由于SPARC体系结构对原子操作缺乏指令级的支持，所以32位int类型的低8位被嵌入了一个锁
（最新SPARC允许提供全32位atomic_t，这一限制不存在了）

 64位原子操作：
```
type struct {
    violatile long counter;
} atomic64_t;
```

### 原子位操作

针对位的一组原子操作函数, 传入一个内存地址和位号

### 自旋锁

自旋锁可以使用在中断处理程序中(此处不能使用信号量,因为他们会导致睡眠). 在中断处理程序中使用自旋锁时, 一定要在获取锁之前, 首先禁止本地中断(在当前处理器上的中断请求), 否则, 中断处理程序就会打断正在持有锁的内核代码, 有可能会试图去争用这个已经被持有的自旋锁. 这样一来, 中断处理程序就会自旋, 等待该锁重新可用, 但是锁的持有者在这个中断处理程序执行完毕前不可能运行 (注意: 需要关闭的只是当前处理器上的中断)

#### 自旋锁与下半部

- 由于下半部可以抢占进程上下文的代码, 所以当下半部和进程上下文共享数据时, 加锁的同时还要禁止下半部执行

- 由于中断处理程序可以抢占下半部, 所以如果中断处理程序和下半部共享数据, 加锁的同时还要禁止中断

### 信号量

1. 信号量适用于锁会被长时间持有的情况. 相反, 锁被短时间持有时, 信号量不太适合, 因为睡眠、维护等待队列以及唤醒所花费的开销可能比锁被占用的全部时间还要长
2. 执行线程在锁被争用时会睡眠, 所以只能在进程上下文中才能获取信号量锁, 因为在中断上下文中是不能进行调度的
3. 可以在持有信号量时去睡眠, 并不会导致死锁
4. 占用信号量的同时不能占用自旋锁, 因为等待信号量时可能会睡眠, 而在持有自旋锁时是不允许睡眠的

往往在需要和用户空间同步时, 代码会需要睡眠, 此时使用信号量是唯一的选择

#### 计数信号量和互斥信号量

计数信号量: count > 1

互斥信号量/二值信号量: count = 1

### 互斥体

mutex, 相当于一个简化版的二值信号量

### 完成变量

如果在内核中的一个任务需要发出信号通知另一任务发生了某个特定事件, 利用完成变量是使两个任务得以同步的简单方法

例如, 当子进程执行或者退出时, vfork()系统调用使用完成变量唤醒父进程

### 顺序锁(seq锁)

实现这种锁主要依靠一个序列计数器. 在读操作之前和之后都会获取一个序列号, 若序列号相同, 说明在读操作进行的过程中没有被写操作打断过

另外, 对于信号量或者自旋锁所支持的读写锁, 若读的操作很多, 可能会导致写操作被饿死, 而在顺序锁中, 读操作不会影响写操作, 只有写操作会阻塞写操作

时间管理中jiffies就使用了seq锁

### 禁止抢占

一个任务与被抢占的任务可能会在同一个临界区内运行, 为了避免这种情况, 内核抢占代码使用自旋锁作为非抢占区域的标记. 如果一个自旋锁被持有, 内核便不能进行抢占.

**如果数据对每个处理器是唯一的**, 那么这样的数据就不需要使用锁来保护, **因为数据只能被一个处理器访问**, 可以通过preempt_disable()禁止内核抢占

### 顺序和屏障

![a a](https://github.com/zyuce/personal_site_pics/blob/main/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/1635669286%20Large.jpeg)



# 定时器和时间管理

系统定时器以某种频率自行触发(经常被称为击中hitting或射中popping)时钟中断, 该频率可以通过编程预定, 称作节拍率tick rate(单位: HZ). 因为预编的节拍率对内核来说是可知的, 所以内核知道连续两次时钟中断的间隔时间, 这个间隔时间就成为节拍tick

**节拍率普遍100或1000, 提高节拍率使内核定时器有更高的频度和更高的准确度, 劣势是会导致系统负担更重**

利用时间中断周期执行的工作:

- 更新系统运行时间, 更新实际时间
- 在smp系统上, 均衡调度程序中各处理器上的运行队列, 如果队列负载不均衡的话尽量使它们均衡
- 检查当前进程是否用尽了自己的时间片, 如果用尽就重新进行调度
- 运行超时的动态定时器
- 更新资源消耗和处理器时间的统计值

## Jeffies

jeffies用来记录自系统启动以来产生的节拍的总数

## 时钟中断处理程序

大致执行如下工作:

- 获得xtime_lock锁, 以便对访问jiffies_64和墙上时间xtime进行保护
- 需要时应答或重新设置系统时钟
- 周期性的使用墙上时间更新实时时钟(RTC)
- 调用体系结构无关的时钟例程: tick_periodic()

tick_periodic()流程:

- 给jiffies_64变量增加1
- 更新资源消耗的统计值, 比如当前进程所消耗的系统时间和用户时间
- 执行已经到期的动态定时器
- 执行scheduler_tick() (触发抢占)
- 更新墙上时间, 该时间存放在xtime变量中
- 计算平均负载值

tick_periodic()中account_process_tick()对进程的时间进行实质性更新, 但是:

**内核对进程进行时间计数时, 是根据中断发生时处理器所处的模式进行分类统计的, 它把上一个节拍全部算给了进程, 但是事实上进程在上一个节拍期间可能多次进入和退出内核模式, 而且在上一个节拍期间, 该进程也不一定是唯一一个运行进程. 很不幸, 这种力度的进程统计方式是传统的Unix所具有的, 现在还没有更加精密的统计算法, 内核现在只能做到这个程度**

## 定时器

内核在时钟中断处理程序中执行update_process_times()函数, 该函数调用run_local_timers():

```
void run_local_timers(void) {
	hrtimer_run_queues();
	raise_softirq(TIMER_SOFTIRQ); // 执行定时器软中断
	softlockup_tick();
}
```

run_timer_softirq()函数处理软中断TIMER_SOFTIRQ, 从而在当前处理器上运行所有超时定时器

## 延迟执行

### 忙等待

```
unsigned long delay = jiffies + 5*HZ; // 5秒
while(time_before(jiffies, delay))
	cond_resched();
```

cond_resched()函数将调度一个新程序投入运行, 但它只有在设置完need_resched标志后才能生效. 换句话说, 该方法有效的条件是系统中存在更重要的任务需要运行.

### 短延迟

假设在1000HZ频率的时钟中断下(节拍间隔1ms), 需要短暂等待某个动作(小于1ms)

可以使用内核延迟函数:

```
void udelay(unsigned long usecs)
void ndelay(unsigned long nsecs)
void mdelay(unsigned long msecs)
```

分别是ms, ns, ms级别的延迟函数, 具体实现是通过BogoMIPS

#### BogoMIPS

通过记录处理器在空闲时速度有多快, 记录至loops_per_jiffy, 延迟函数通过loops_per_jiffy来计算为提供精确延迟而需要进行多少次循环

### schedule_timeout()

基于内核定时器实现的简单应用

# 虚拟文件系统

VFS对用户提供统一的读写等文件操作调用接口，当用户调用读写函数时，内核则调用特定的文件系统实现。

## 对象模型

### 超级块对象 superblock object

存放已安装文件系统的有关信息

### 索引节点对象 index node object

存放关于具体文件的一般信息

### 文件对象 file object

存放打开文件与进程之间的交互信息

### 目录项对象 dentry object

存放目录项与对应文件进行链接的有关信息


